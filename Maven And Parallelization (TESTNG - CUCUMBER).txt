
Topics in it: 
- MAVEN
- Parallelization (TestNG / Cucumber)


MAVEN is a project build tool for java projects. There are other build tools for java such as Gradle and Ant. 

Build tools automate the process of creating, managing dependencies, compiling, testing, deploying java applications.	

An XML file always located on home folder of the project which is always called pom.xml. Contains all important information about the project and configuration details used to build the project. Contains default values for most projects.

Maven automates the build process of Java projects. Each phase in the build process is known as a Maven lifecycle or a Maven goal.

Maven helps us to automate all processes starting from creating project till deployment.

Deployment ==> it's a process of delivering new version of software to any application server.

Release ==> it's a process of delivering new version of software to the end-user.

Web service - it's an application, that process some data and works through web. ==> Exp: GitHub

application server - it's a software that hosts web service. ==> Exp: Git

Maven is also responsible for dependencies. We have to download and add all .jar files we need for project if don't use Maven. Maven automatically downloads and adds into project.Dependencies helps us to easily add libraries and make project independent from IDE. We can run tests without IDE. (Jenkins execute tests by using Maven, not any IDE)

* In terminal you can use vim or nano to edit files. CONTROL + C - to stop any process in terminal.

* * * Before running any maven life-cycle command in terminal, you must be in the same level with your pom.xml

For Windows: open your project folder --> right click on empty space --> git bash here

For Mac: run pwd to get path of current location, or just drag and drop project folder into terminal to get path to it. put cd before to navigate there.

Maven Default Lifecycles
? clean - remove all files generated by the previous build (deletes Target file)
? validate - validate the project is correct and all necessary information is available
? compile - compile the source code of the project
? test - test the compiled source code using a suitable unit testing framework
? verify - run any checks to verify the package is valid and meets quality criteria
? package - converts built project into distributable version such as .jar or .war
? install - Install the built artifact into the local repository.
? deploy - Deploy the built artifact to the remote repository.

***To run any maven goal, we type "mvn" then the goal. We also have to be in the project folder where the pom file is located. 

- mvn clean ==> delete target folder
- mvn clean test ==> delete target folder and run cucumber tests
- mvn clean verify ==> delete target folder, run cucumber test, generate cucumber HTML report
- mvn clean verify -P Regression ==> delete target folder, run cucumber test, generate cucumber HTML report or whatever was specified in Regression profile in pom.xml.
- mvn verify -Dcucumber.options="--tags @smoke_test"
- mvn verify -Dcucumber.options="--tags @login_with_role"
- mvn verify -Dbrowser=firefox --> to run with firefox
- mvn verify -Dbrowser=chrome --> to run with chrome
- mvn verify -Dbrowser=firefox -Dcucumber.options="--tags @login_with_role" --> to run with firefox and only specific tags
if report is failing, run with test goal
- mvn test -Dbrowser=chrome --> to run with chrome

- to read browser parameter in your project, use System.getProperty("browser")

- Dcucumber.options="--tags @sometag" --> provide scenarios that you want to run. No need to change CucumberRunner class. It overrides runner class configuration.

If you see "BUILD SUCCESS" at the end of any Maven LifeCycle that means all maven goals were executed and project is ready to use.

If CucumberRunner didn't fail, there is nothing to execute for FailedRunner. But, the problem is that they share reports. Thus, cucumber.json file will be overridden by FailedRunner and it will be empty. Failed runner shouldn't generate json report ==> see below:

@CucumberOptions(
        features = "@target/rerun.txt",
        glue = "com/vytrack/step_definitions",
        plugin = {
                "html:target/rerun-default-cucumber-reports",  ==> There is no json report statement
        }
)
public class FailedRunner {
}

clear - to clear terminal

As a tester, I use maven to create my test automation framework, manage dependencies, run my tests, generate reports. 
Maven has goals also known as lifecycles. mvn compile, mvn test etc…
Maven project always has 3 things: 
    pom.xml file (project configuration, dependencies)  
    src folder (for the actual code)
    target folder (for compiled classes, for reports)
Companies may use their own repository/nexus. We add a ".settings" file in the maven home folder. Get this file  from your coworkers, or company documentation. 
User home folder —> folder created for each user in the computer. In Mac it is in the /Users/ folder, in windows it is in C://Users/
maven home folder —> maven creates a folder called ".m2" in the user folder. 

to read browser parameter in your project, use System.getProperty("browser")

You can pass any parameters from command line.

mvn test -P Regression --> to kick off regression. We have Regression profile in pom.xml file. Profiles let's have multiple build configurations. Also, regression profile runs RegressionRunner.java class. RegressionRunner class has list of features that were selected for regression.

<profiles>
        <profile>
            <id>Regression</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-surefire-plugin</artifactId>
                        <version>3.0.0-M3</version>
                        <configuration>
                            <includes>
                                <include>**/RegressionRunner.java</include>
                            </includes>
                            <testFailureIgnore>true</testFailureIgnore>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>

============================================================

RUNNING TESTS IN PARALLEL PART I : TESTNG FRAMEWORK
In my framework  we use singleton object for the web driver. This means one object is shared among every test. Singleton makes parallelization hard because single WebDriver object is not shared between tests/threads.
How to make sure each thread gets a separate/dedicated web driver? 
InheritableThreadLocal creates a separate object for each thread. In our framework, we run parallel by running different test in different threads. They in turn get their WebDriver object from the InheritableThreadLocal. 
How to actually run in parallel?
In the xml file there is option parallel=“tests”. This means can run tests in parallel.  
thread-count=“3" —> this contorts how many threads we have open in one time. Our number of browsers is controlled by this. 
Using maven-surefire-plugin we can say which xml runner we want to execute. 
    
We can either put the file in the pom file or make it a variable so that we can pass it from terminal. 
mvn test -Drunner=smoke_test_parallel_with_different_browsers.xml 

============================================================

RUNNING TESTS IN PARALLEL PART II : CUCUMBER FRAMEWORK
Since cucumber version 4, Cucumber supports parallelization out of the box. For this purpose; Cucumber uses the maven surefire plugin. In the maven surefire plugin configuration, we have following options we can add:

<parallel>methods</parallel> ==> —> runs each feature file separately (we can put class instead of method)
<perCoreThreadCount>false</perCoreThreadCount>
<threadCountMethods>2</threadCountMethods>
<includes>
    <include>**/RegressionRunner.java</include>
</includes>

mvn clean verify -Dbrowser=firefox 
mvn verify -Dbrowser=firefox?mvn verify -Dcucumber.options=“--tags @login_with_role”
mvn verify -Dcucumber.options=“--tags @smoke_test”
mvn verify -Dbrowser=chrome -P Regression

